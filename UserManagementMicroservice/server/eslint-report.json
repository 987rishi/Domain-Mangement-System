[{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\app.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":38,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":50,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":55}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express, { Express, Request, Response, NextFunction } from \"express\";\r\nimport mainRouter from \"./routes/index.routes.js\"; // Import the main router from routes/index.ts\r\n\r\n\r\nconst app: Express = express();\r\n\r\n/**\r\n * @module Server\r\n * @description Initializes and configures the Express server.\r\n */\r\n\r\n// --- Middleware ---\r\n\r\n/**\r\n * Parses incoming JSON requests and puts the parsed data in `req.body`.\r\n */\r\napp.use(express.json());\r\n\r\n\r\n\r\n// --- Routes ---\r\n\r\n/**\r\n * Mounts the main router containing all API routes.\r\n */\r\napp.use(mainRouter);\r\n\r\n// --- Error Handling ---\r\n\r\n/**\r\n * Middleware to handle 404 Not Found errors.\r\n * This will be triggered if no matching route is found.\r\n *\r\n * @param req - Express Request object\r\n * @param res - Express Response object\r\n * @param next - Express NextFunction callback\r\n */\r\napp.use((req: Request, res: Response, next: NextFunction) => {\r\n  res.status(404).json({ message: \"Resource not found\" });\r\n});\r\n\r\n/**\r\n * Global error handler middleware for handling uncaught errors.\r\n *\r\n * @param err - Error object\r\n * @param req - Express Request object\r\n * @param res - Express Response object\r\n * @param next - Express NextFunction callback\r\n */\r\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\r\n  console.error(\"Unhandled Error:\", err.stack);\r\n  res.status(500).json({ message: \"Internal Server Error\" });\r\n});\r\n\r\nexport default app;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\config\\database.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\config\\index.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\controllers\\assigmentController.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7994,7997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7994,7997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport { findUserByIdentifier } from \"../services/ldapAuth\";\r\nimport prisma from \"../config/database.config\";\r\nimport { Role } from \"@prisma/client\";\r\nimport { stringifyBigInts } from \"../utils/userController.helper\";\r\nimport { assignmentSchemaValidation } from \"../middleware/schemaValidation\";\r\nimport { formatError } from \"../utils/helper\";\r\n\r\n/**\r\n     * This is the transaction that creates the project assignment. If any of the\r\n     * operations inside the transaction throw an error, the entire transaction\r\n     * will be rolled back.\r\n     * \r\n     * This is the helper function that checks if a user exists in the appUser\r\n     * table and is active in the respective table (either the drm table or\r\n     * the arm table). If the user doesn't exist in the appUser table, it\r\n     * fetches the user from LDAP and creates a new record in the appUser table.\r\n     * It then creates a new record in either the drm table or the arm table,\r\n     * depending on the role that was passed in.\r\n     * \r\n     \r\n*/\r\n\r\n  /**\r\n   * This endpoint creates a new project assignment. It takes in the project name,\r\n   * project remarks, DRM employee number, and ARM employee number. It then checks\r\n   * if all of the required fields are present, and if not, returns a 400 error\r\n   * response. If all of the required fields are present, it proceeds to create\r\n   * the project assignment.\r\n   *\r\n   * The project assignment is created in a transaction, meaning that either all\r\n   * of the operations in the transaction succeed, or none of them do. This is\r\n   * important because we don't want to have a situation where the project\r\n   * assignment is created, but the DRM and ARM users aren't. Or vice versa.\r\n   *\r\n   * Inside the transaction, we first try to find the HOD user by their employee\r\n   * number. If the HOD user isn't found, we throw an error that will cause the\r\n   * transaction to rollback. If the HOD user is found, we extract the centre ID\r\n   * and group ID from their record.\r\n   *\r\n   * Next, we define a helper function called `validateUserAndStatus`. This\r\n   * function takes in an employee number, a role (either \"DRM\" or \"ARM\"), and a\r\n   * table name (either \"drm\" or \"arm\"). It then checks if the user with the\r\n   * given employee number exists in the appUser table. If the user exists, it\r\n   * checks if the user is active in the respective table (either the drm table\r\n   * or the arm table). If the user is not active, it throws an error. If the\r\n   * user is active, it returns without doing anything else.\r\n   *\r\n   * If the user doesn't exist in the appUser table, it fetches the user from\r\n   * LDAP and creates a new record in the appUser table. It then creates a new\r\n   * record in either the drm table or the arm table, depending on the role that\r\n   * was passed in.\r\n   *\r\n   * After defining the `validateUserAndStatus` function, we call it twice: once\r\n   * for the DRM user, and once for the ARM user. If either of these calls\r\n   * throws an error, the transaction will rollback.\r\n   *\r\n   * Finally, we create the project assignment itself. We do this only after\r\n   * checking that the DRM and ARM users exist and are active.\r\n   */\r\nexport const assignmentController = async (\r\n  req: Request,\r\n  res: Response\r\n): Promise<void> => {\r\n\r\n// const { project_name, project_remarks,drm_emp_no,arm_emp_no} = req.body;\r\n  const assignDrmArmBody = req.body;\r\n  const payload = assignmentSchemaValidation.safeParse(assignDrmArmBody);\r\n    if (!payload.success) {\r\n      const errors = formatError(payload.error);\r\n      // console.log(\"Validation error:\", errors);\r\n      res.status(422).json({ message: \"Validation error\", errors });\r\n      return;\r\n    }\r\n\r\n  const project_name = payload.data.project_name;\r\n  const project_remarks = payload.data.project_remarks;\r\n  const drm_emp_no = payload.data.drm_emp_no;\r\n  const arm_emp_no = payload.data.arm_emp_no;\r\n  \r\n  const hod_emp_no = req.user?.id;\r\n  console.log(\"The hod emp no is: \",hod_emp_no)\r\n\r\n  if(!hod_emp_no){\r\n    res.status(401).json({message:\"Not a valid Users\"})\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Create a new transaction\r\n    const result = await prisma.$transaction(async (tx) => {\r\n      // Find the HOD user by their employee number\r\n      const hod = await tx.hod.findUnique({\r\n        where: { emp_no: BigInt(hod_emp_no) },\r\n      });\r\n\r\n      if (!hod) throw new Error(\"HOD not found in database\");\r\n\r\n      // Extract the centre ID and group ID from the HOD record\r\n      const { centre_id, grp_id } = hod;\r\n\r\n      // Define the validateUserAndStatus function\r\n      const validateUserAndStatus = async (\r\n        emp_no: number,\r\n        role: Role,\r\n        table: \"drm\" | \"arm\"\r\n      ) => {\r\n        // Check if the user already exists in the appUser table\r\n        const existingUser = await tx.appUser.findUnique({ where: { emp_no } });\r\n\r\n        if (existingUser) {\r\n          // Check if the user is active in the respective table\r\n          const roleRecord = await (table === \"drm\"\r\n            ? tx.drm.findUnique({ where: { emp_no } })\r\n            : tx.arm.findUnique({ where: { emp_no } }));\r\n\r\n          if (!roleRecord?.is_active) {\r\n            // If the user is not active, throw an error that will cause the transaction to rollback\r\n            throw new Error(\r\n              `${table.toUpperCase()} with emp_no ${emp_no} is not active.`\r\n            );\r\n          }\r\n\r\n          // Optional: check for conflicts with LDAP here if needed\r\n          return;\r\n        }\r\n\r\n        // If the user doesn't exist, fetch from LDAP and create as usual\r\n        const ldapData = await findUserByIdentifier(emp_no);\r\n        if (!ldapData) throw new Error(`${role} not found in LDAP.`);\r\n\r\n        // Split the full name into first name and last name\r\n        const [firstName, ...rest] = ldapData.fullName.split(\" \");\r\n        const lastName = rest.join(\" \") || \"\";\r\n\r\n        // Create a new record in the appUser table\r\n        await tx.appUser.create({\r\n          data: {\r\n            emp_no,\r\n            usr_email: ldapData.employeeEmail,\r\n            usr_fname: firstName,\r\n            usr_lname: lastName,\r\n            role,\r\n            centre_id,\r\n          },\r\n        });\r\n\r\n        // Create a new record in either the drm table or the arm table\r\n        if (table === \"drm\") {\r\n          await tx.drm.create({\r\n            data: {\r\n              emp_no,\r\n              email_id: ldapData.employeeEmail,\r\n              drm_fname: firstName,\r\n              drm_lname: lastName,\r\n              desig: null,\r\n              tele_no: null,\r\n              mob_no: null,\r\n              centre_id,\r\n              grp_id,\r\n            },\r\n          });\r\n        } else {\r\n          await tx.arm.create({\r\n            data: {\r\n              emp_no,\r\n              email_id: ldapData.employeeEmail,\r\n              arm_fname: firstName,\r\n              arm_lname: lastName,\r\n              desig: null,\r\n              tele_no: null,\r\n              mob_no: null,\r\n              centre_id,\r\n              grp_id,\r\n            },\r\n          });\r\n        }\r\n      };\r\n\r\n      // Call the validateUserAndStatus function for the DRM user\r\n      await validateUserAndStatus(Number(drm_emp_no), Role.DRM, \"drm\");\r\n\r\n      // Call the validateUserAndStatus function for the ARM user\r\n      await validateUserAndStatus(Number(arm_emp_no), Role.ARM, \"arm\");\r\n\r\n      // Create the project assignment only after the users and roles exist\r\n      const assignment = await tx.projectAssignment.create({\r\n        data: {\r\n          project_name,\r\n          project_remarks,\r\n          hod_emp_no:BigInt(hod_emp_no),\r\n          drm_emp_no:BigInt(drm_emp_no),\r\n          arm_emp_no:BigInt(arm_emp_no),\r\n        },\r\n      });\r\n\r\n      return assignment;\r\n    });\r\n\r\n    // Return the result of the transaction\r\n    res.status(201).json({ message: \"Project assigned successfully\", result: stringifyBigInts(result) });\r\n  } catch (error: any) {\r\n    console.error(\"Assignment error:\", error);\r\n    res\r\n      .status(500)\r\n      .json({ message: error.message || \"Error assigning project.\" });\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\controllers\\updateController.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\controllers\\userController.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Role' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bigint' is defined but never used.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2172,2175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2172,2175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4106,4109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4106,4109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":182,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":223,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":259,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":259,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":294,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":294,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":438,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14166,14169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14166,14169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/controllers/userController.ts\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport prisma from \"../config/database.config.js\";\r\nimport { Role } from \"@prisma/client\"; // Import the enum\r\nimport {\r\n  getRoleInfo,\r\n  stringifyBigInts\r\n} from \"../utils/userController.helper.js\";\r\nimport { bigint } from \"zod\";\r\n\r\nexport const getUserDetails = async (req:Request,res:Response):Promise<void> => {\r\n  const emp_no = req.params.empNo;\r\n  if(!emp_no){\r\n    res.status(400).json({ message: \"Invalid employee number.\" });\r\n    return;\r\n  }\r\n  try {\r\n    const userData = await prisma.appUser.findUnique({\r\n      where: {\r\n        emp_no: BigInt(emp_no),\r\n      },\r\n    });\r\n    \r\n    if (!userData) {\r\n      res.status(404).json({\r\n        message: `User details not found for employee number '${emp_no}'.`,\r\n      });\r\n      return;\r\n    }\r\n\r\n    res.status(200).json(stringifyBigInts(userData));\r\n  } catch (error) {\r\n    res.status(400).json({ message: \"Internal Server error in fetching details from user service\" });\r\n    console.log(error);\r\n    return;\r\n  }\r\n  \r\n};\r\n\r\n/**\r\n *  GET: /api/users/details/:role/:empNo\r\n * \r\n *  Fetches full details for a specific user from their corresponding role table.\r\n * \r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @param {NextFunction} next - Express middleware function\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getUserDetailsByRole = async (\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n): Promise<void> => {\r\n  const { role, empNo } = req.params;\r\n  const empNoBigInt = BigInt(empNo); // Convert param string to BigInt\r\n\r\n  try {\r\n    const roleInfo = getRoleInfo(role);\r\n    if (!roleInfo) {\r\n      // This check is technically redundant due to express-validator, but good practice\r\n      res.status(400).json({ message: \"Invalid role specified.\" });\r\n      return;\r\n    }\r\n\r\n    // Query the specific role table (e.g., prisma.drmList, prisma.hodList)\r\n    // The type assertion `as any` is sometimes needed because Prisma's model types vary\r\n    const userDetails = await (roleInfo as any).findUnique({\r\n      where: { emp_no: empNoBigInt }, // Find by employee number (which is the PK/FK)\r\n    });\r\n\r\n    if (!userDetails) {\r\n      res.status(404).json({\r\n        message: `User details not found for role '${role}' and employee number '${empNo}'.`,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Important: Check if the base user is active (if included) or if the role record has its own active flag\r\n    if (\r\n      (userDetails.user && !userDetails.user.is_active) ||\r\n      !userDetails.is_active\r\n    ) {\r\n      res.status(404).json({\r\n        message: `User details not found for role '${role}' and employee number '${empNo}' (user may be inactive).`,\r\n      });\r\n      return;\r\n    }\r\n    // Serialize BigInts to strings before sending\r\n    res.status(200).json(stringifyBigInts(userDetails));\r\n  } catch (error) {\r\n    // Catch potential BigInt conversion errors or other issues\r\n    if (error instanceof Error && error.message.includes(\"Cannot convert\")) {\r\n      res.status(400).json({ message: \"Invalid employee number format.\" });\r\n      return;\r\n    }\r\n    next(error);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * GET /api/users/list/:role\r\n * \r\n * Fetches a list of all active users belonging to a specific role.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @param {NextFunction} next - Express next function\r\n */\r\nexport const getUserListByRole = async (\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n): Promise<void> => {\r\n  const { role } = req.params;\r\n\r\n  try {\r\n    // Get the role info object from the role enum value\r\n    const roleInfo = getRoleInfo(role);\r\n    if (!roleInfo) {\r\n      // If not found, return a 400 error with a user-friendly message\r\n      res.status(400).json({ message: \"Invalid role specified.\" });\r\n      return;\r\n    }\r\n\r\n    // Query the specific role table for all active users\r\n    const userList = await (roleInfo as any).findMany({\r\n      // Filter by the active flag on the role table itself\r\n      where: {\r\n        is_active: true,\r\n      },\r\n      // Optional: Add default sorting\r\n      orderBy: {\r\n        // Sort by last name if user is included\r\n        emp_no: \"asc\",\r\n        // Or sort by a field on the role table directly, e.g., emp_no: 'asc'\r\n      },\r\n      // TODO: Add pagination later if needed (using skip, take)\r\n    });\r\n\r\n    // Serialize BigInts before sending\r\n    res.status(200).json(stringifyBigInts(userList));\r\n  } catch (error) {\r\n    // Catch any errors and pass them to the next function\r\n    next(error);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * GET /api/users/centre/:centreid\r\n * \r\n * Fetches a single centre by its ID and provide all information of that centre\r\n * \r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getCentreList = async (\r\n  req: Request,\r\n  res: Response\r\n): Promise<void> => {\r\n  const { centreid } = req.params;\r\n  try {\r\n    // Get the centre from the database by its ID\r\n    const centre = await prisma.centre.findUnique({\r\n      where: {\r\n        // Use the centre_id as the lookup key\r\n        centre_id: parseInt(centreid),\r\n      },\r\n    });\r\n\r\n    if (!centre) {\r\n      // If the centre isn't found, return a 404 error with a user-friendly message\r\n      res.status(404).json({ error: \"Centre not found.\" });\r\n      return;\r\n    }\r\n\r\n    // Send the centre data as JSON\r\n    res.status(200).json(centre);\r\n  } catch (error) {\r\n    // Catch any errors and send a 400 error with a user-friendly message\r\n    res.status(400).send(`No centre found for centre_id ${centreid}`);\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * GET /api/users/group/:groupid\r\n * \r\n * Fetches a single group department by its ID.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getGroupList = async (\r\n  req: Request,\r\n  res: Response\r\n): Promise<void> => {\r\n  // Extract the group ID from the URL parameters\r\n  const { groupid } = req.params;\r\n\r\n  try {\r\n    // Query the database to find the group department by its ID\r\n    const group = await prisma.groupDepartment.findUnique({\r\n      where: {\r\n        // Use the dept_id as the lookup key\r\n        dept_id: parseInt(groupid),\r\n      },\r\n    });\r\n\r\n    // If the group isn't found, return a 404 error with a user-friendly message\r\n    if (!group) {\r\n      res.status(404).json({ error: \"Group not found.\" });\r\n      return;\r\n    }\r\n\r\n    // Send the group data as JSON\r\n    res.status(200).json(group);\r\n  } catch (error) {\r\n    // Catch any errors and send a 400 error with a user-friendly message\r\n    res.status(400).send(`No group found for group_id ${groupid}`);\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * GET /api/users/allgroups\r\n * \r\n * Retrieves all group departments from the database in ascending order of department ID.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getAllGroupList = async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    // Retrieve all group departments from the database, ordered by department ID in ascending order\r\n    const allGroups = await prisma.groupDepartment.findMany({\r\n      // Sort the results by department ID in ascending order\r\n      orderBy: {\r\n        dept_id: 'asc',\r\n      },\r\n    });\r\n\r\n    // Check if the query returned no results\r\n    if (!allGroups) {\r\n      // Respond with a 400 status code and an error message if no groups were found\r\n      res.status(400).send(\"Error in finding groups\");\r\n      return;\r\n    }\r\n\r\n    // Respond with a 200 status code and the list of groups as JSON if found\r\n    res.status(200).json(allGroups);\r\n  } catch (error) {\r\n    // Catch any unexpected errors that occur during the execution\r\n    res.status(500).send(\"An error occurred while retrieving groups\");\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * GET /api/users/allcentres\r\n * \r\n * Retrieves all centres from the database in ascending order of centre ID.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getAllCentreList = async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    // Retrieve all centres from the database, ordered by centre ID in ascending order\r\n    const allGroups = await prisma.centre.findMany({\r\n      // Sort the results by centre ID in ascending order\r\n      orderBy: {\r\n        centre_id: 'asc',\r\n      },\r\n    });\r\n\r\n    // Check if the query returned no results\r\n    if (!allGroups) {\r\n      // Respond with a 400 status code and an error message if no groups were found\r\n      res.status(400).send(\"Error in finding groups\");\r\n      return;\r\n    }\r\n\r\n    // Respond with a 200 status code and the list of groups as JSON if found\r\n    res.status(200).json(allGroups);\r\n  } catch (error) {\r\n    // Catch any unexpected errors that occur during the execution\r\n    res.status(500).send(\"An error occurred while retrieving groups\");\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * GET /api/users/:empNo/officials\r\n * \r\n * Retrieves the HOD and NetOps member responsible for the specified user.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getResponsibleOfficials = async (\r\n  req: Request,\r\n  res: Response\r\n): Promise<void> => {\r\n  // Extract employee number from request parameters\r\n  const { empNo } = req.params;\r\n\r\n  try {\r\n    // Find the user in the appUser table by their employee number\r\n    const user = await prisma.appUser.findUnique({\r\n      where: { emp_no: BigInt(empNo) },\r\n    });\r\n\r\n    // If user is not found, return a 404 error response\r\n    if (!user) {\r\n      res.status(404).json({ error: \"User not found.\" });\r\n      return;\r\n    }\r\n\r\n    // Initialize variables for centre and department IDs\r\n    let centreId: number | null = null;\r\n    let deptId: number | null = null;\r\n\r\n    // Check the role of the user and fetch corresponding details\r\n    if (user.role === \"DRM\") {\r\n      // If role is DRM, find the DRM record by employee number\r\n      const drm = await prisma.drm.findUnique({\r\n        where: { emp_no: BigInt(empNo) },\r\n        select: {\r\n          centre_id: true,\r\n          grp_id: true,\r\n          is_active: true,\r\n        },\r\n      });\r\n\r\n      // If DRM record is not found or not active, return a 404 error response\r\n      if (!drm || !drm.is_active) {\r\n        res.status(404).json({ error: \"DRM is not active.\" });\r\n        return;\r\n      }\r\n\r\n      // Set centre and department IDs from DRM record\r\n      centreId = drm.centre_id;\r\n      deptId = drm.grp_id;\r\n    } else if (user.role === \"ARM\") {\r\n      // If role is ARM, find the ARM record by employee number\r\n      const arm = await prisma.arm.findUnique({\r\n        where: { emp_no: BigInt(empNo) },\r\n        select: {\r\n          centre_id: true,\r\n          grp_id: true,\r\n          is_active: true,\r\n        },\r\n      });\r\n\r\n      // If ARM record is not found or not active, return a 404 error response\r\n      if (!arm || !arm.is_active) {\r\n        res.status(404).json({ error: \"DRM is not active.\" });\r\n        return;\r\n      }\r\n\r\n      // Set centre and department IDs from ARM record\r\n      centreId = arm.centre_id;\r\n      deptId = arm.grp_id;\r\n    } else {\r\n      // If role is neither DRM nor ARM, return a 400 error response\r\n      res.status(400).json({ error: \"Only DRM or ARM roles are supported.\" });\r\n      return;\r\n    }\r\n\r\n    // Find the HOD for the centre and department\r\nconst [hod, netops, ed, webmaster, hodHpcIandE] = await Promise.all([\r\n  // Find HOD for the specific department and centre\r\n  prisma.hod.findFirst({\r\n    // Assuming model name HodList\r\n    where: {\r\n      grp_id: deptId,\r\n      centre_id: centreId,\r\n      is_active: true,\r\n    },\r\n    select: { emp_no: true, hod_fname: true, hod_lname: true, email_id: true }, // Use specific HOD fields\r\n  }),\r\n  // Find NetOps for the specific centre\r\n  prisma.memberNetops.findUnique({\r\n    // Assuming model name MemberNetops\r\n    // The schema implies centre_id is unique on MemberNetops, so findUnique is appropriate\r\n    where: { centre_id: centreId /* , is_active: true */ }, // is_active might not be on the where unique clause\r\n    select: {\r\n      emp_no: true,\r\n      fname: true,\r\n      lname: true,\r\n      email_id: true,\r\n      is_active: true,\r\n    },\r\n  }),\r\n  // Find ED (Centre Head) for the specific centre\r\n  prisma.edCentreHead.findUnique({\r\n    // Assuming model name EdCentreHead\r\n    where: { centre_id: centreId /* , is_active: true */ },\r\n    select: {\r\n      emp_no: true,\r\n      fname: true,\r\n      lname: true,\r\n      email_id: true,\r\n      is_active: true,\r\n    },\r\n  }),\r\n  // Find Webmaster for the specific centre\r\n  prisma.webMaster.findFirst({\r\n    // Using findFirst for safety, assuming model name WebMaster\r\n    where: { centre_id: centreId, is_active: true },\r\n    select: { emp_no: true, fname: true, lname: true, email_id: true },\r\n  }),\r\n  // Find the specific HOD HPC I&E (assuming only one active system-wide based on schema)\r\n  prisma.hodHpcIandE.findFirst({\r\n    // Assuming model name HodHpcIandE\r\n    where: { is_active: true },\r\n    select: { emp_no: true, fname: true, lname: true, email_id: true },\r\n  }),\r\n]);\r\n\r\n// Filter out inactive officials before sending response (double-check)\r\nconst activeNetops = netops?.is_active ? netops : null;\r\nconst activeEd = ed?.is_active ? ed : null;\r\n// Assuming hod, webmaster, hodHpcIandE queries already filter by is_active\r\n\r\n// 4. Respond with all fetched details\r\n// Convert BigInt emp_no to strings for JSON compatibility before sending\r\nconst stringifyEmpNo = (official: any) =>\r\n  official ? { ...official, emp_no: official.emp_no.toString() } : null;\r\n\r\nres.json({\r\n  requestingUserRole: user.role, // Role of the user making the request\r\n  hod: stringifyEmpNo(hod), // HOD of the specific Group/Centre\r\n  netops: stringifyEmpNo(activeNetops), // NetOps of the specific Centre\r\n  ed: stringifyEmpNo(activeEd), // ED of the specific Centre\r\n  webmaster: stringifyEmpNo(webmaster), // Webmaster of the specific Centre\r\n  hodHpcIandE: stringifyEmpNo(hodHpcIandE), // The specific HPC/I&E HOD role\r\n});\r\n    return;\r\n  } catch (error) {\r\n    // Log the error to the console and respond with a 500 error\r\n    console.error(\r\n      \"Error fetching responsible officials:\",\r\n      error instanceof Error ? error.message : error\r\n    );\r\n    res.status(500).json({ error: \"Internal server error\" });\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * GET /api/projects/:empNo\r\n * \r\n * Fetches a list of projects that the specified employee number is associated with.\r\n * \r\n * The association is determined by the following conditions:\r\n * \r\n * 1. The employee is the HOD of the project.\r\n * 2. The employee is the ARM of the project.\r\n * 3. The employee is the DRM of the project.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getProjectList = async (req: Request, res: Response): Promise<void> => {\r\n  const { empNo } = req.params;\r\n  const employeeNo = BigInt(empNo);\r\n  if(!employeeNo){\r\n    res.status(400).json({ message: \"Invalid employee number.\" });\r\n    return;\r\n  }\r\n  try {\r\n    // Find all projects where the employee number matches one of the roles\r\n    const projects = await prisma.projectAssignment.findMany({\r\n      where: {\r\n        // Use the OR operator to match any of the following conditions\r\n        OR: [\r\n          // The employee is the HOD of the project\r\n          { hod_emp_no: employeeNo },\r\n          // The employee is the ARM of the project\r\n          { arm_emp_no: employeeNo },\r\n          // The employee is the DRM of the project\r\n          { drm_emp_no: employeeNo },\r\n        ],\r\n      },\r\n      // Include the DRM, ARM, and HOD details in the response\r\n      include: {\r\n        drm: true,\r\n        arm: true,\r\n        hod: true,\r\n      },\r\n    });\r\n    if (projects.length === 0) {\r\n      res.status(404).json({ message: \"No projects found for employee number\" });\r\n      return;\r\n    }\r\n    // Return the list of projects\r\n    res.status(200).json(stringifyBigInts(projects));\r\n    return;\r\n  } catch (error) {\r\n    // If there's an error, log it and return a 404 error with a message\r\n    console.error(\r\n      \"Error fetching projects for employee number %s:\",\r\n      empNo,\r\n      error instanceof Error ? error.message : error\r\n    );\r\n    res.status(404).json({ message: \"Error in fetching projects\" });\r\n    return;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * GET /api/projects/:projectId\r\n * \r\n * Retrieves the details of a project by its project ID.\r\n * \r\n * The response will include the DRM, ARM, and HOD details associated with the project.\r\n *\r\n * @param {Request} req - Express request object\r\n * @param {Response} res - Express response object\r\n * @returns {Promise<void>} - Promise indicating successful completion\r\n */\r\nexport const getProjectDetails = async (req: Request, res: Response): Promise<void> => {\r\n  const { projectId } = req.params;\r\n  try {\r\n    // Find the project assignment record by its project ID\r\n    const projectDetails = await prisma.projectAssignment.findUnique({\r\n      // Use the project ID as the lookup key\r\n      where: { project_id: BigInt(projectId) },\r\n      // Include the DRM, ARM, and HOD details in the response\r\n      include: {\r\n        // Include the DRM (Data Repository Manager) details\r\n        drm: true,\r\n        // Include the ARM (Application Repository Manager) details\r\n        arm: true,\r\n        // Include the HOD (Head of Department) details\r\n        hod: true,\r\n      },\r\n    });\r\n\r\n    // If the project assignment record is not found, return a 404 error with a message\r\n    if (!getProjectDetails) {\r\n      res.status(404).json({ error: \"Project not found.\" });\r\n      return;\r\n    }\r\n    if (!projectDetails?.hod || !projectDetails.hod.centre_id) {\r\n      console.error(\r\n        `HOD details or Centre ID missing for project ${projectId}`\r\n      );\r\n      res\r\n        .status(404)\r\n        .json({\r\n          error:\r\n            \"Associated HOD or Centre information missing for the project.\",\r\n        });\r\n      return;\r\n    }\r\n    if (!projectDetails.hod.is_active) {\r\n      res\r\n        .status(404)\r\n        .json({ error: \"The HOD associated with this project is inactive.\" });\r\n      return;\r\n    }\r\n\r\n    const centreId = projectDetails.hod.centre_id; // Get centreId from the project's HOD\r\n\r\n    // 2. Fetch emp_no for other relevant officials based on centreId or globally\r\n    // Using Promise.all for efficiency\r\n    const [edInfo, netopsInfo, webmasterInfo, hodHpcInfo] = await Promise.all([\r\n      // ED for the centre\r\n      prisma.edCentreHead.findUnique({\r\n        where: { centre_id: centreId },\r\n        select: { emp_no: true, is_active: true }, // Only fetch emp_no and active status\r\n      }),\r\n      // NetOps for the centre\r\n      prisma.memberNetops.findUnique({\r\n        where: { centre_id: centreId },\r\n        select: { emp_no: true, is_active: true },\r\n      }),\r\n      // Webmaster for the centre (finding the first active one)\r\n      prisma.webMaster.findFirst({\r\n        where: { centre_id: centreId, is_active: true },\r\n        select: { emp_no: true }, // Assume already filtered by active\r\n      }),\r\n      // HodHpcIandE (finding the first active one globally)\r\n      prisma.hodHpcIandE.findFirst({\r\n        where: { is_active: true },\r\n        select: { emp_no: true },\r\n      }),\r\n    ]);\r\n\r\n    // Filter out inactive ED/NetOps\r\n    const activeEdEmpNo = edInfo?.is_active ? edInfo.emp_no : null;\r\n    const activeNetopsEmpNo = netopsInfo?.is_active ? netopsInfo.emp_no : null;\r\n\r\n    // 3. Construct the final response object\r\n    const responseData = {\r\n      ...projectDetails, // Include original project details (DRM, ARM, HOD objects)\r\n      // Add the additional employee numbers\r\n      responsibleOfficials: {\r\n        hod_emp_no: projectDetails.hod.emp_no, // Already fetched\r\n        ed_emp_no: activeEdEmpNo,\r\n        netops_emp_no: activeNetopsEmpNo,\r\n        webmaster_emp_no: webmasterInfo?.emp_no || null, // Use optional chaining\r\n        hod_hpc_iande_emp_no: hodHpcInfo?.emp_no || null, // Use optional chaining\r\n      },\r\n    };\r\n    // Return the project assignment record, including the DRM, ARM, and HOD details\r\n    res.status(200).json(stringifyBigInts(responseData));\r\n  } catch (error) {\r\n    // If there's an error, log it and return a 404 error with a message\r\n    console.error(\r\n      \"Error fetching project details for project_id %s:\",\r\n      projectId,\r\n      error instanceof Error ? error.message : error\r\n    );\r\n    res.status(404).send(`No project found for project_id ${projectId}`);\r\n  }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\middleware\\authMiddleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\middleware\\schemaValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\middleware\\validateUserParams.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":1,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":1,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const expressValidator = require(\"express-validator\");\r\nconst { param } = expressValidator;\r\n\r\n\r\nexport const validateUserParams = [\r\n  param(\"role\").custom((value: string) => {\r\n    const allowedRoles = [\r\n      \"DRM\",\r\n      \"ARM\",\r\n      \"HOD\",\r\n      \"ED\",\r\n      \"NETOPS\",\r\n      \"WEBMASTER\",\r\n      \"HODHPC\",\r\n    ];\r\n    if (!allowedRoles.includes(value.toUpperCase())) {\r\n      throw new Error(\"Invalid role specified.\");\r\n    }\r\n    return true;\r\n  }),\r\n\r\n  param(\"empNo\")\r\n    .isString()\r\n    .matches(/^\\d+$/)\r\n    .withMessage(\r\n      \"Employee number must be a numeric string representing a bigint.\"\r\n    ),\r\n];\r\n\r\nexport const validateUserRole = \r\n  param(\"role\").custom((value: string) => {\r\n    const allowedRoles = [\r\n      \"DRM\",\r\n      \"ARM\",\r\n      \"HOD\",\r\n      \"ED\",\r\n      \"NETOPS\",\r\n      \"WEBMASTER\",\r\n      \"HODHPC\",\r\n    ];\r\n    if (!allowedRoles.includes(value.toUpperCase())) {\r\n      throw new Error(\"Invalid role specified.\");\r\n    }\r\n    return true;\r\n  });\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\routes\\assign.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\routes\\auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\routes\\index.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\routes\\update.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\routes\\user.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\services\\ldapAuth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SearchCallbackResponse' is defined but never used.","line":2,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'result' is defined but never used.","line":268,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":268,"endColumn":30}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ldap, {\r\n  SearchCallbackResponse,\r\n  SearchOptions,\r\n  SearchEntry,\r\n} from \"ldapjs\";\r\nimport jwt from 'jsonwebtoken';\r\nimport dotenv from \"dotenv\";\r\nimport config from \"../config/index.config\";\r\n\r\nimport { getUserRole,getUserGroupByRole } from \"../utils/userController.helper\";\r\nimport { Role } from \"@prisma/client\";\r\nimport {user,MyUser} from '../types/userType';\r\ndotenv.config();\r\n\r\nconst LDAP_URL = config.ldap.url;\r\nconst BIND_DN = config.ldap.bindDN;\r\nconst BIND_PASSWORD = config.ldap.bindPassword;\r\nconst BASE_DN = config.ldap.searchBase;\r\n\r\n\r\n \r\n\r\n// Helper function to convert an LDAP entry's attributes array to a plain object\r\n/**\r\n * Converts an LDAP entry's attributes array to a plain object of type Partial<MyUser>.\r\n * \r\n * The function iterates over each attribute in the entry's attributes array and checks\r\n * if the attribute has a valid type and non-empty values array. If so, it maps the\r\n * attribute's type to a key in the MyUser interface and stores the first value from the\r\n * attribute's values array in the object.\r\n * \r\n * @param {SearchEntry} entry - The LDAP entry whose attributes should be converted to an object\r\n * @returns {Partial<MyUser>} - An object with attributes mapped to MyUser keys\r\n */\r\nconst ldapEntryToObject = (entry: SearchEntry): Partial<MyUser> => {\r\n  // Initialize an empty object of type Partial<MyUser> to store converted attributes\r\n  const obj: Partial<MyUser> = {};\r\n  \r\n  // Iterate over each attribute in the entry's attributes array\r\n  for (const attribute of entry.attributes) {\r\n    // Check if the attribute has a valid type and non-empty values array\r\n    if (attribute.type && attribute.values && attribute.values.length > 0) {\r\n      // Map the attribute's type to a key in the MyUser interface\r\n      // Store the first value from the attribute's values array in the object\r\n      obj[attribute.type as keyof MyUser] = attribute.values[0];\r\n    }\r\n  }\r\n  \r\n  // Return the constructed object with attributes mapped to MyUser keys\r\n  return obj;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Authenticates a user against an LDAP directory using their email and password.\r\n * \r\n * This function binds to the LDAP server using admin credentials to search for\r\n * a user by their email address. If a user is found, their Distinguished Name\r\n * (DN) and other attributes are retrieved. The user's credentials are then\r\n * verified by attempting to bind again using their DN and the provided password.\r\n * \r\n * If authentication is successful, the user's role and group information are\r\n * also retrieved and returned.\r\n * \r\n * @param {string} email - The email address of the user to authenticate.\r\n * @param {string} password - The password of the user to authenticate.\r\n * @returns {Promise<Object>} - A promise that resolves to an object containing\r\n * the user's ID, full name, email, center, role, and group if authentication\r\n * is successful. The promise is rejected with an error message if authentication\r\n * fails or if any required information is not found.\r\n * \r\n * @throws {Object} If there are issues with binding to the LDAP server, searching\r\n * for the user, or verifying the user's credentials.\r\n */\r\nexport const authenticateUser = async (email: string, password: string): Promise<user> => {\r\n  return new Promise((resolve, reject) => {\r\n    // Create an LDAP client connected to the LDAP server\r\n    const client = ldap.createClient({ url: LDAP_URL });\r\n\r\n    // Bind to the LDAP server using the admin DN and password\r\n    // This allows us to perform a search for the user with the specified email\r\n    client.bind(BIND_DN, BIND_PASSWORD, (err) => {\r\n      if (err) {\r\n        // If the bind fails, unbind the client and reject the promise with an\r\n        // error object\r\n        client.unbind();\r\n        return reject({message:\"Admin Bind Failed\"});\r\n      }\r\n\r\n      // Define search options for the LDAP search\r\n      const opts: SearchOptions = {\r\n        // The filter to use for the search. In this case, we're searching for\r\n        // the user whose email address matches the email passed to the function\r\n        filter: `(mail=${email})`,\r\n        // The scope of the search. In this case, we're performing a subtree\r\n        // search, which means that we'll search all entries in the subtree\r\n        // rooted at the base DN.\r\n        scope: \"sub\",\r\n        // The attributes to return in the search results. In this case, we're\r\n        // asking for the user's common name (cn), email address (mail), and\r\n        // group ID number (gidNumber).\r\n        attributes: [\"uidNumber\", \"cn\", \"mail\", \"gidNumber\"], // don't ask for \"dn\" here\r\n      };\r\n\r\n      // Perform the search\r\n      client.search(BASE_DN, opts, (err, res) => {\r\n        if (err) {\r\n          // If the search fails, unbind the client and reject the promise with an\r\n          // error object\r\n          client.unbind();\r\n          return reject({message:\"LDAP Search Error\"});\r\n        }\r\n\r\n        // Initialize variables to store the user's DN, uidNumber, full name,\r\n        // email address, and centre\r\n        let userDn = \"\";\r\n        let uidNumber: string | null = null;\r\n        let fullName: string | null = null;\r\n        let employeeEmail: string | null = null;\r\n        let employeeCenter: string | null = null;\r\n        \r\n\r\n        // Set up event listeners for the search results. We're interested in the\r\n        // searchEntry event, which is fired for each entry in the search results.\r\n        res.on(\"searchEntry\", (entry: SearchEntry) => {\r\n          userDn = entry.dn.toString(); \r\n          console.log(\"User DN:\", userDn);\r\n\r\n          // Convert the entry's attributes array to a plain object with attributes\r\n          // mapped to keys in the MyUser interface\r\n          const obj = ldapEntryToObject(entry) as MyUser;\r\n\r\n          // Store the user's uidNumber, full name, email address, and group ID number\r\n          // in the variables initialized above\r\n          uidNumber = obj.uidNumber;\r\n          fullName = obj.cn;\r\n          employeeEmail = obj.mail;\r\n\r\n          // Extract the user's centre from the user's DN\r\n          const centreMatch = userDn.match(/ou=([A-Z]{2}),ou=User/i);\r\n          employeeCenter = centreMatch ? centreMatch[1].toUpperCase() : null;\r\n\r\n          console.log(\"UID Number:\", uidNumber);\r\n          console.log(\"Full Name:\", fullName);\r\n          console.log(\"Email:\", employeeEmail);\r\n          console.log(\"Centre:\", employeeCenter);\r\n        });\r\n\r\n        // When the search is complete, unbind the client and check if the user\r\n        // was found\r\n        res.on(\"end\", async () => {\r\n          if (!userDn || !employeeEmail) {\r\n            client.unbind();\r\n            return reject({message:\"User Not Found\"});\r\n          }\r\n\r\n          // Bind to the LDAP server again using the user's DN and password\r\n          // This allows us to verify the user's credentials\r\n          client.bind(userDn, password, async (err) => {\r\n            if (err) {\r\n              client.unbind();\r\n              return reject({message:\"Invalid Credentials\"});\r\n            }\r\n            console.log(\"user authenticated\");\r\n\r\n            // Unbind the client\r\n            client.unbind();\r\n\r\n            // Get the user's role\r\n            const role = await getUserRole(uidNumber!);\r\n\r\n            // Get the user's group\r\n            const employeeGroup = await getUserGroupByRole(uidNumber!, role);\r\n\r\n            // Resolve the promise with the user's info\r\n            resolve({\r\n              id: Number(uidNumber),\r\n              name:fullName,\r\n              employeeEmail,\r\n              employeeCenter,\r\n              role,\r\n              employeeGroup\r\n            });\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Finds a user by their unique identifier (uidNumber) in the LDAP directory.\r\n * \r\n * This function connects to the LDAP server and performs a search query to\r\n * locate a user whose uidNumber matches the provided identifier. If a user\r\n * is found, their full name and email address are returned.\r\n * \r\n * @param {number} identifier - The unique identifier (uidNumber) of the user to search for.\r\n * @returns {Promise<{employeeEmail: string, fullName: string}>} - A promise resolving to an object\r\n * containing the user's email address and full name. If no user is found, the promise is rejected.\r\n * \r\n * @throws {Error} If there are issues with binding to the LDAP server or performing the search.\r\n */\r\nexport const findUserByIdentifier = async (identifier:number):Promise<{employeeEmail:string,fullName:string}> => {\r\n  return new Promise((resolve, reject) => {\r\n    const client = ldap.createClient({ url: LDAP_URL });\r\n\r\n    // Bind to the LDAP server using the admin DN and password.\r\n    // This is done to ensure that the search is performed with the necessary\r\n    // permissions.\r\n    client.bind(BIND_DN, BIND_PASSWORD, (err) => {\r\n      if (err) {\r\n        // If the bind fails, unbind the client and reject the promise with an\r\n        // error object.\r\n        client.unbind();\r\n        return reject(new Error(\"Admin Bind Failed\"));\r\n      }\r\n\r\n      // Define search options\r\n      const opts: SearchOptions = {\r\n        // The filter to use for the search. In this case, we're searching for\r\n        // the user whose uidnumber matches the parameter passed to the function.\r\n        filter: `uidNumber=${identifier}`,\r\n        // The scope of the search. In this case, we're performing a subtree\r\n        // search, which means that we'll search all entries in the subtree\r\n        // rooted at the base DN.\r\n        scope: \"sub\",\r\n        // The attributes to return in the search results. In this case, we're\r\n        // asking for the user's common name (cn) and email address (mail).\r\n        attributes: [\"cn\", \"mail\"],\r\n      };\r\n       \r\n      // Perform the search\r\n      client.search(BASE_DN, opts, (err, res) => {\r\n        if (err) {\r\n          // If the search fails, unbind the client and reject the promise with an\r\n          // error object.\r\n          client.unbind();\r\n          return reject(new Error(\"LDAP Search Error\"));\r\n        }\r\n\r\n        // Initialize variables to store the user's full name and email address.\r\n        let fullName: string | null = null;\r\n        let employeeEmail: string | null = null;\r\n\r\n        // Set up event listeners for the search results. We're interested in the\r\n        // searchEntry event, which is fired for each entry in the search results.\r\n        res.on(\"searchEntry\", (entry:SearchEntry) => {\r\n          const obj = ldapEntryToObject(entry) as MyUser;\r\n          fullName = obj.cn;\r\n          employeeEmail = obj.mail;\r\n          console.log(\"Full Name:\", fullName);\r\n          console.log(\"email:\", employeeEmail);\r\n        });\r\n\r\n        // Set up an event listener for the error event. If an error occurs, we'll\r\n        // unbind the client and reject the promise with an error object.\r\n        res.on(\"error\", (err) => {\r\n          client.unbind();\r\n          reject(new Error(`LDAP Search Error: ${err.message}`));\r\n        });\r\n\r\n        // Set up an event listener for the end event, which is fired when the\r\n        // search is complete. If the search was successful, we'll resolve the\r\n        // promise with an object containing the user's full name and email address.\r\n        // If the search failed, we'll reject the promise with an error object.\r\n        res.on(\"end\", (result) => {\r\n          if (!fullName || !employeeEmail) {\r\n            client.unbind();\r\n            reject(new Error(\"User not found\"));\r\n          } else {\r\n            resolve({\r\n              employeeEmail,\r\n              fullName\r\n            })\r\n          }\r\n          client.unbind();\r\n        });\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/** \r\n* Helper function to generate token given id\r\n* This function takes in the id, email and role of the user and returns a JSON Web Token (JWT)\r\n* The JWT is signed with a secret key, which is stored in the environment variable JWT_SECRET\r\n* The secret key is expected to be a base64 encoded string\r\n* The function returns a promise that resolves to the JWT\r\n* The JWT is valid for 1 day\r\n*/ \r\nexport const generateToken = (id: number,email:string,role:Role): string => {\r\n  // Get the secret key from the environment variable\r\n  const base64Secret = config.jwt.secret;\r\n\r\n  // Convert the base64 encoded secret key to a Buffer\r\n  const secret = Buffer.from(base64Secret, \"base64\");\r\n\r\n  // Create the payload for the JWT\r\n  // The payload contains the id, email and role of the user\r\n  const payload = {\r\n    id,\r\n    email,\r\n    role\r\n  };\r\n\r\n  // Sign the payload with the secret key and return the JWT\r\n  const token = jwt.sign(payload, secret, { expiresIn: \"1d\" });\r\n\r\n  // Log the JWT to the console\r\n  console.log(\"token:\", token);\r\n\r\n  // Return the JWT\r\n  return token;\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\types\\gloabalTypes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Role' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":14},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":4,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":8,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[121,124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[121,124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Role } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      user?: any; // You can replace `any` with a specific type if you know the JWT payload structure\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\types\\userType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\utils\\helper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35,38],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35,38],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41,44],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41,44],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'errors' is never reassigned. Use 'const' instead.","line":2,"column":7,"nodeType":"Identifier","messageId":"useConst","endLine":2,"endColumn":18,"fix":{"range":[53,74],"text":"const errors: any = {};"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[65,68],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[65,68],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[104,107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[104,107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"export const formatError = (error: any): any => {\r\n  let errors: any = {};\r\n  error.errors?.map((issue: any) => {\r\n    errors[issue.path?.[0]] = issue.message;\r\n  });\r\n  return errors;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\utils\\serviceDiscovery.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'networkInterfaces' is assigned a value but never used.","line":17,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express, { Request, Response } from \"express\";\r\nimport dotenv from \"dotenv\";\r\nimport { Eureka } from \"eureka-js-client\";\r\n\r\nimport os from \"os\";\r\n\r\ndotenv.config();\r\nconst app = express();\r\n// app.use(cors());\r\n// app.use(express.json());\r\n\r\nconst PORT = Number(process.env.UMMS_PORT) || 5000;\r\nconst EUREKA_HOST = process.env.EUREKA_HOST || \"localhost\";\r\nconst EUREKA_PORT = process.env.EUREKA_PORT || \"8761\";\r\n\r\n// Get the actual network IP\r\nconst networkInterfaces = os.networkInterfaces();\r\n// const localIP =\r\n//   Object.values(networkInterfaces)\r\n//     .flat()\r\n//     .find((iface) => iface && iface.family === \"IPv4\" && !iface.internal)\r\n//     ?.address || \"127.0.0.1\";\r\nfunction getLocalIpAddress(): string {\r\n  // 1. Check for explicit override via environment variable\r\n  const explicitHostIp = process.env.HOST_IP;\r\n  if (explicitHostIp) {\r\n    console.log(` Using explicitly set HOST_IP: ${explicitHostIp}`);\r\n    return explicitHostIp;\r\n  }\r\n\r\n  // 2. Attempt to find a suitable IP from network interfaces\r\n  const networkInterfaces = os.networkInterfaces();\r\n  const candidates: string[] = [];\r\n\r\n  for (const interfaceName in networkInterfaces) {\r\n    const interfaces = networkInterfaces[interfaceName];\r\n    if (interfaces) {\r\n      for (const iface of interfaces) {\r\n        // Skip over internal (i.e. 127.0.0.1) and non-IPv4 addresses\r\n        // Skip over link-local addresses (169.254.x.x) which are not typically routable\r\n        if (\r\n          iface.family === \"IPv4\" &&\r\n          !iface.internal &&\r\n          !iface.address.startsWith(\"169.254.\")\r\n        ) {\r\n          // Prioritize common interface names if possible, though this is not perfectly reliable\r\n          if (\r\n            [\"eth0\", \"en0\", \"wlan0\", \"wifi0\"].includes(\r\n              interfaceName.toLowerCase()\r\n            )\r\n          ) {\r\n            candidates.unshift(iface.address); // Add to the beginning (higher priority)\r\n          } else {\r\n            candidates.push(iface.address); // Add to the end\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (candidates.length > 0) {\r\n    // Return the first candidate (which might have been prioritized)\r\n    console.log(\r\n      ` Automatically detected IP Address: ${\r\n        candidates[0]\r\n      }. Candidates: ${candidates.join(\", \")}`\r\n    );\r\n    return candidates[0];\r\n  }\r\n\r\n  // 3. Fallback if no suitable IP is found\r\n  console.warn(\r\n    \" Could not automatically determine a suitable non-internal IPv4 address. Falling back to '127.0.0.1'. \" +\r\n      \"Consider setting the HOST_IP environment variable if this service needs to be accessible externally.\"\r\n  );\r\n  return \"127.0.0.1\";\r\n}\r\n\r\n// const localIP = `100.88.57.62`\r\nconst localIP = getLocalIpAddress();\r\n\r\nconsole.log(` Service IP Address: ${localIP}`);\r\n\r\napp.get(\"/\", (req: Request, res: Response) => {\r\n  res.json({ message: \"Hello from Node.js Eureka Microservice!\" });\r\n});\r\n\r\n//  Eureka Client Configuration\r\nexport const eurekaClient = new Eureka({\r\n  instance: {\r\n    app: \"user-management-service\",\r\n    instanceId: `user-management-service-${PORT}`,\r\n    hostName: localIP, //  Use actual network IP\r\n    ipAddr: localIP, //  Use actual network IP\r\n    statusPageUrl: `http://${localIP}:${PORT}`, //  Use actual network IP\r\n    port: {\r\n      \"@enabled\": true,\r\n      $: Number(PORT),\r\n    },\r\n    vipAddress: \"user-management-service\",\r\n    dataCenterInfo: {\r\n      \"@class\": \"com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo\",\r\n      name: \"MyOwn\",\r\n    },\r\n  },\r\n  eureka: {\r\n    host: EUREKA_HOST,\r\n    port: Number(EUREKA_PORT),\r\n    servicePath: \"/eureka/apps/\",\r\n  },\r\n});\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Rishi\\Desktop\\Projects\\CdacDnsManagementSystem\\UserManagementMicroservice\\server\\src\\utils\\userController.helper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1467,1470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1467,1470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1473,1476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1473,1476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1967,1970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1967,1970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3963,3966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3963,3966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5560,5563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5560,5563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Role } from \"@prisma/client\";\r\nimport prisma from \"../config/database.config\";\r\n\r\n/**\r\n * Maps a role string to the corresponding Prisma model.\r\n * \r\n * The role string is case-insensitive.\r\n * \r\n * If the role is not recognized, returns null.\r\n * \r\n * @param {string} roleString - The role string (e.g. \"DRM\", \"HOD\", \"ED\", etc.)\r\n * \r\n * @returns {Model | null} The Prisma model for the given role, or null if not recognized.\r\n */\r\nexport const getRoleInfo = (roleString: string) => {\r\n  switch (roleString.toLowerCase()) {\r\n    case \"drm\":\r\n      return prisma.drm;\r\n    case \"arm\":\r\n      return prisma.arm;\r\n    case \"hod\":\r\n      return prisma.hod;\r\n    case \"ed\":\r\n      return prisma.edCentreHead; // ED not directly linked to GroupDept in schema\r\n    case \"webmaster\":\r\n      return prisma.webMaster; // Webmaster not linked to GroupDept\r\n    case \"netops\":\r\n      return prisma.memberNetops;\r\n    // NetOps not linked to GroupDept\r\n    case \"hodhpc\":\r\n      return prisma.hodHpcIandE; // HodHpc not linked to Centre/Group\r\n    default:\r\n      return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Recursively converts BigInt values within an object or array to strings.\r\n * \r\n * This is necessary because JSON.stringify does not handle BigInt values.\r\n *\r\n * @param {any} obj - The input object or array containing potential BigInt values.\r\n * @returns {any} A new object or array with all BigInt values converted to strings.\r\n */\r\nexport const stringifyBigInts = (obj: any): any => {\r\n  // Recursion base case: if obj is not an object or array, just return it as-is\r\n  if (obj === null || typeof obj !== \"object\") {\r\n    return obj;\r\n  }\r\n\r\n  // If obj is an array, recursively process each element of the array\r\n  if (Array.isArray(obj)) {\r\n    return obj.map(stringifyBigInts);\r\n  }\r\n\r\n  // If obj is an object, create a new object (newObj) with the same key-value pairs\r\n  // as obj, but with any BigInt values converted to strings\r\n  const newObj: { [key: string]: any } = {};\r\n  for (const key in obj) {\r\n    // Check that the key is a valid property of obj (not a prototype property)\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      const value = obj[key];\r\n\r\n      // If the value is a BigInt, convert it to a string\r\n      if (typeof value === \"bigint\") {\r\n        newObj[key] = value.toString();\r\n      }\r\n      // If the value is an object or array, recursively process it\r\n      else if (typeof value === \"object\") {\r\n        newObj[key] = stringifyBigInts(value); // Recursively process nested objects/arrays\r\n      }\r\n      // Otherwise, just copy the value as-is\r\n      else {\r\n        newObj[key] = value;\r\n      }\r\n    }\r\n  }\r\n  return newObj;\r\n};\r\n\r\n\r\n/**\r\n * Retrieves the role of a user based on their employee number.\r\n * \r\n * @param {string|bigint} empNo - Employee number of the user\r\n * @returns {Promise<Role>} - Promise resolving to the role of the user\r\n */\r\nexport const getUserRole = async (\r\n  empNo: string | bigint\r\n): Promise<Role> => {\r\n  try {\r\n    // Convert input to BigInt for Prisma query\r\n    // This is necessary because Prisma expects a BigInt for the where clause\r\n    const empNoBigInt = BigInt(empNo);\r\n\r\n    // Find the user in the appUser table by their employee number\r\n    const user = await prisma.appUser.findUnique({\r\n      // Assuming model name is 'User'\r\n      where: { emp_no: empNoBigInt },\r\n      // Select only the role and active status of the user\r\n      // This is necessary because we don't want to fetch the entire user record\r\n      select: { role: true },\r\n    });\r\n\r\n    // If user is not found, log an error and throw an error\r\n    if (!user) {\r\n      console.log(\r\n        `User with emp_no ${empNo} not found in application database.`\r\n      );\r\n      throw new Error(\"User not provisioned in this app\"); // User not provisioned in this app\r\n    }\r\n\r\n    // Return the role of the user\r\n    // This is the final result of the function\r\n    return user.role;\r\n\r\n  } catch (error: any) {\r\n    // Handle potential BigInt conversion errors\r\n    // This can happen if the input is not a valid BigInt\r\n    if (error instanceof Error && error.message.includes(\"Cannot convert\")) {\r\n      console.error(`Invalid employee number format for role lookup: ${empNo}`);\r\n      throw new Error(\"Cannot look up role with invalid empNo format\"); // Cannot look up role with invalid empNo format\r\n    }\r\n    // Handle other database errors\r\n    // This can happen if there is an issue with the database connection\r\n    console.error(`Error fetching role for emp_no ${empNo}:`, error);\r\n    // Re-throw the error to be handled by the caller (e.g., login service)\r\n    throw new Error(`Database error fetching user role: ${error.message}`);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Retrieves the group name associated with a user's role.\r\n * \r\n * @param {string} empNo - The employee number of the user\r\n * @param {Role} role - The role of the user (e.g. DRM, ARM, HOD, etc.)\r\n * @returns {Promise<string | null>} - A promise resolving to the group name or null if no such group exists\r\n */\r\nexport const getUserGroupByRole = async (empNo: string, role: Role): Promise<string | null> => {\r\n  // Get the Prisma model associated with the given role\r\n  const userRole = getRoleInfo(role);\r\n  if (!userRole) {\r\n    // If the role is not recognized, throw an error\r\n    throw new Error(\"Role not found\");\r\n  }\r\n\r\n  // Convert the employee number to a BigInt for Prisma query\r\n  const empNoBigInt = BigInt(empNo);\r\n\r\n  // Find the user record in the role table by their employee number\r\n  const user = await (userRole as any).findUnique({\r\n    where: { emp_no: empNoBigInt },\r\n  });\r\n\r\n  // If the user is not found, return null\r\n  if (!user) {\r\n    return null;\r\n  }\r\n\r\n  if (!user.grp_id) {\r\n    return null;\r\n  }\r\n  // Get the group name associated with the user's department ID\r\n  const group = await prisma.groupDepartment.findUnique({\r\n    where: { dept_id: user.grp_id },\r\n    select: { d_name: true },\r\n  });\r\n\r\n  // Return the group name or null if no such group exists\r\n  return group?.d_name ?? null;\r\n};","usedDeprecatedRules":[]}]